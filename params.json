{"name":"Cf-extension","tagline":"","body":"CF-extesion使用文档\r\n====================\r\n\r\n前言\r\n------------------\r\n本文为CF-extesion的使用文档，该平台实现了对应用动态更新的支持\r\n\r\n\r\n\r\n源码下载\r\n---------------\r\n  首先从gitlab上下载源码,如果是从别人处copy的源码，一定要注意文件夹以及可执行文件的权限问题。否则部署应用的时候，会出现没有权限等问题。\r\n  \r\n  \r\nhost machine环境设置\r\n-------------------\r\n \r\n我们的实验环境是Ubuntu 12.04，如果需要使用git，则需要先下载git\r\n\r\n```\r\nsudo apt-get install git \r\n\r\n```\r\n\r\n从gitlab上下载的源码，需要使用[Vagrant][1]和[VirtualBox][2]工具，开启一个虚拟机\r\n\r\n首先下载vagrant安装包，\r\nDownload it from http://www.vagrantup.com (version 1.2 or higher)\r\nInstall required plugins: \r\n\r\n```\r\n vagrant plugin install vagrant-berkshelf\r\n \r\n vagrant plugin install vagrant-omnibus\r\n\r\n```\r\n\r\n\r\n\r\n\r\n根目录下的VagrantFile设置了虚拟机的内存、cpu、使用的虚拟机镜像等信息，可做相应的修改\r\n\r\n启动虚拟机\r\n------------------------\r\n\r\n```\r\nvagrant up\r\n\r\n```\r\n\r\nvagrant up需要联网进行，因为有一些下载工作。\r\n\r\n\r\n此时如果是第一次创建虚拟机，那么需要较长的时间，首先是从远程下载一个虚拟机镜像，然后根据VagrantFile中的设置新建一个Ubuntu系统的虚拟机实例。\r\n\r\n当vagrant up成功时，vagrant ssh进入虚拟机。\r\n\r\n#### 如果报错chef-golang没有访问权限，则执行./rm.sh\r\n这个错误的原因，可能是因为vagrant使用chef工具安装go-lang失败。\r\n\r\n进入虚拟机\r\n-------------------\r\n\r\n\r\n```\r\nvagrant ssh\r\n\r\n```\r\n\r\n\r\n安装虚拟机环境：git、ruby、java等\r\n-------------------------\r\n\r\n#### 1 首先安装git，\r\n\r\n```\r\n\r\n sudo apt-get upgrade\r\n\r\n sudo apt-get install git\r\n\r\n\r\n```\r\n可能会出现缺少liberror-curl的包，可以手动下载[8]，然后dpkg -i 安装。\r\n\r\n\r\n####  2 接着安装ruby\r\n\r\n安装rbenv\r\n\r\n```\r\ngit clone git://github.com/sstephenson/rbenv.git ~/.rbenv\r\ngit clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build\r\ngit clone git://github.com/jamis/rbenv-gemset.git  ~/.rbenv/plugins/rbenv-gemset\r\ngit clone git://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash\r\n\r\n```\r\n下面 将 rbenv 加入到 $PATH 里\r\n\r\n```\r\nvi ~/.bash_profile\r\n```\r\n\r\n输入的内容：\r\n\r\n```\r\nexport PATH=\"$HOME/.rbenv/bin:$PATH\"\r\neval \"$(rbenv init -)\"\r\n```\r\n最后执行\r\n\r\n```\r\nsource ~/.bash_profile\r\n```\r\n\r\n安装ruby\r\n\r\n```\r\nrbenv install --list  # 列出所有 ruby 版本\r\nrbenv install 1.9.3-p392     # 安装 1.9.3-p392\r\n\r\n ```\r\n 设置版本\r\n \r\n ```\t\t\r\nrbenv global 1.9.3-p392      # 默认使用 1.9.3-p392\r\nrbenv shell 1.9.3-p392    # 当前的 shell 使用 1.9.3-p392, 会设置一个 RBENV_VERSION 环境变量\r\nrbenv local 1.9.3-p392      # 当前目录使用 ruby1.9.3, 会生成一个 .rbenv-version 文件\r\n\r\n```\r\n\r\n\r\n#### 3 安装Java\r\n\r\n[下载][4],如果下载的版本名为jdk-7u40-linux-x64.tar.gz\r\n\r\n```\r\nsudo mkdir /usr/lib/jvm\r\nsudo tar zxvf jdk-7u40-linux-x64.tar.gz -C /usr/lib/jvm\r\ncd /usr/lib/jvm/\r\nsudo mv jdk1.7.0/ java-7-sun \r\n\r\n```\r\n\r\n设置环境变量\r\nvim ~/.bash_profile \r\n\r\n\r\n```\r\nexport JAVA_HOME=/usr/lib/jvm/java-7-sun  \r\nexport JRE_HOME=${JAVA_HOME}/jre  \r\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \r\nexport PATH=${JAVA_HOME}/bin:$PATH \r\nsource ~/.bash_profile  \r\n\r\n\r\n```\r\n\r\n#### 4 install maven : \r\n\r\n```\r\n  sudo apt-get install maven\r\n  \r\n```\r\n  \r\n#### 5 安装make : \r\n\r\n```\r\n  apt-get install build-essential\r\n\r\n```\r\n\r\n#### 6 安装zip、golang，curl等，\r\n\r\n\r\n```\r\n\r\n  cd /vagrant \r\n  \r\n  sudo apt-get install golang-go\r\n  \r\n  gem install bundle\r\n  \r\n  apt-get install zip\r\n\t\r\n  apt-get install curl\t\r\n```\r\n\r\n#### 7 执行Rake脚本\r\n\r\n```\r\n  rake cf:bootstrap \r\n  \r\n```\r\n （在执行这一步之前，需要保证ruby，java，mvn等都已安装）\r\n\r\n如果执行失败，可以修复错误后，多次执行该脚本\r\n\r\n执行成功后，安装就告一段落\r\n\r\n\r\n设置warden容器\r\n---------------------------\r\n[参考][5]\r\n\r\n\r\n\r\n#### 1 首先是warden需要setup，安装warden前准备工作：debootstrap，quota，\r\n\r\n\r\n\r\n\r\n```\r\n  sudo apt-get install debootstrap\r\n  \r\n  sudo apt-get install quota\r\n\r\n```\r\n\r\n\r\n#### 2 setup warden container, 进入目录warden/warden执行\r\n \r\n```\r\n sudo bundle exec rake setup[config/linux.yml] \r\n\r\n```\r\n\r\n\r\n 这里可以将warden/config/linux.yml安装stemcell的路径改为/var/warden/rootfs，否则每次关闭vagrant，stemcell就没了。\r\n \r\nrake setup在/tmp/warden目录下，使用debootstrap和chroot工具创建了一个linux系统。\r\n\r\n###如果因为更新系统导致/vagrant不见了\r\n\r\n```\r\n\r\n  sudo apt-get install linux-headers-‘uname -r’ \r\n\r\n  vagrant plugin installvagrant-vbguest\r\n  \r\n  gem install plugin vagrant-vbguest\r\n\r\n\r\n```\r\n\r\n然后ssh进虚拟机就有共享目录了。(最好就是不要安装linux镜像)\r\n\r\n\r\n#### 3 运行warden-server\r\n然后可以在warden/warden路径下开启warden server，并且可以开启warden client，与warden server进行交互。\r\n如果在cf中启动warden，记得去掉bin/warden中的sudo。\r\n在bin/warden第4行，删除rbenv\r\n\r\n```\r\n  sudo bundle exec rake warden:start[config/linux.yml]\r\n\r\n```\r\n\r\n#### 4 在warden container中安装软件\r\n\r\nwarden是cloud foundry v2中用来进行进程、资源隔离的一个重要组件，但是由于warden本身比较复杂，因此我在warden的setup，start，以及生成的stemcell中花费了大量的时间。warden setup时，会使用debootstrap，从宿主机器上克隆一个stemcell的镜像。\r\n\r\n  我的问题在于，虽然环境变量成功clone了，但是文件共享这里却出了问题。\r\n比如镜像挂载，等等。所以我宿主机器的软件，在stemcell中都没有，很多需要手动安装\r\n首先进入/var/warden/rootfs\r\n\r\n```\r\ncd /var/warden/rootfs\r\nsudo chroot .\r\n \r\n```\r\n\r\n进入warden container容器中安装软件：zip，quota，gcc，wget, ruby，jvm\r\n\r\n\r\n```\r\napt-get update \r\napt-get install zip\r\napt-get install quota\r\napt-get install gcc\r\napt-get install wget\r\napt-get install curl\r\n\r\n\r\n\r\n```\r\n\r\n后面两个要使用源码安装。在stemcell中用rbenv安装ruby时，总是会出问题，于是只能源码安装了，在安装前，必须安装一些依赖库。\r\n\r\n\r\n安装ruby前，先安装yaml，否则报错\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n    $ wget http://pyyaml.org/download/libyaml/yaml-0.1.4.tar.gz\r\n\r\n    $ tar xzvf yaml-0.1.4.tar.gz\r\n\r\n    $ cd yaml-0.1.4\r\n\r\n    $ ./configure --prefix=/usr/local\r\n\r\n    $ make\r\n\r\n    $ make install\r\n\r\n```\r\n\r\n然后安装ruby\r\n\r\n\r\n```\r\n\r\n    #下载ruby-1.9.3-p392.tar.gz\r\n\r\n    wget http://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.3-p392.tar.gz\r\n\r\n    #解压，tar -xzvf ruby-1.9.3-p392.tar.gz\r\n\r\n    cd ruby-1.9.3-p392\r\n\r\n    ./configure --prefix=/usr --enable-shared --disable-install-doc --with-opt-dir=/usr/local/lib\r\n\r\n    #编译并安装，即\r\n    make && make install\r\n    \r\n```\r\n\r\n\r\n启动Cloud Foundry各组件\r\n----------------------------\r\n\r\n现在你就可以启动你本地的CloudFoundry了。\r\n\r\n```\r\n  cd /vagrant\r\n  \r\n  ./start.sh #启动各组件\r\n  \r\n  ./stop.sh #停止组件运行\r\n  \r\n  ./status.sh #查看当前组件运行状态\r\n\r\n```\r\n\r\n运行各个组件后，通过status查看其状态，当所有的组件都运行成功后，说明Cloud Foundry平台搭建成功。\r\n\r\n\r\n\r\n创建Cloud Foundry用户\r\n------------------------\r\n\r\n下面是创建用户，运行bin/init_cf_cli脚本中执行的命令\r\n\r\n\r\n```\r\n  cf target http://api.192.168.12.34.xip.io:8181\r\n  \r\n  cf login --username admin --password password\r\n  \r\n  cf create-org myorg\r\n  \r\n  cf create-space myspace\r\n  \r\n  cf switch-space myspace\r\n  \r\n  cd test/helloworld-jsonrpc\r\n  \r\n  cf push\r\n\r\n```\r\n\r\n\r\n生成tuscany-buildpack\r\n--------------------\r\n\r\n\r\n我们部署的实验环境是Tuscany应用，因此需要创建tuscany-buildpack\r\n\r\n我们在dea_ng/buildpacks/vendor/目录下创建tuscany-buildpack，用于部署tuscany应用。由于tuscany源码在运行后，shell模块会等待用户输入，而这里会导致部署在CF上的应用因长时间没有响应而crash，而报错则会指导oom。因此，我们对Tuscany源码的shell部署进行了修改，注释掉等待用户输入的部分。\r\n\r\n并且为tuscany应用定制buildpack打包机制。类似于tomcat，首先下载java源码、部署java运行环境，然后下载修改后的tuscany源码，部署tuscany环境，主要是设置JAVA_HOME,TUSCANY_HOME。然后启动tusncay，运行tuscany.sh app.\r\n\r\n下载源码时，需要从服务器拖，或者在warden-container处建立一个cache，我们选择在cache处建一个下载资源的缓存池。\r\n\r\n```\r\ncd /var/warden/rootfs\r\nsudo chroot .\r\nmkdir -p /var/vcap/packages/buildpack_cache\r\n\r\n\r\n\r\n```\r\n我们在这个缓存目录下存放java-jdk.jar, tuscany.jar,\r\n\r\n\r\n\r\n部署应用\r\n-----------------\r\n现在可以去本地的app\r\n\r\n为了识别出当前应是tuscany应用，我们在helloworld-jsonrpc目录下建立version.tuscany文件，指明使用的tuscany源码版本。\r\n\r\n```\r\ncd /vagrant/test/helloworld-jsonrpc\r\nmvn install -DskipTests (跳过测试，因为tuscany版本的问题，有一些测试用例跑不过去)\r\ncf psuh \r\n\r\n```\r\n\r\n实验是\r\n可以直接运行./push.sh\r\n或者进入每个目录运行部署命令cf push\r\n\r\n\r\n通过cf apps查看应用的状态。\r\n\r\n\r\n通过curl http://someuser:somepassword@10.0.2.15:8081/routes，查看应用是否成功在路由器上注册。这里，如果返回的是{}，说明注册失败。（这里是一个bug，尚未修复）。只能手动kill掉router进程，在重新运行。\r\n\r\n\r\n```\r\nps ax|grep router #然后删除router进程，一般有两个\r\ncd /vagrant/gorouter\r\nsudo ./bin/router -c =/vagrant/custom_config_files/gorouter/gorouter.yml\r\n\r\n\r\n```\r\n\r\n再次查看在router上注册的应用。此时应用有多个应用成功注册。\r\n\r\n\r\n\r\n测试动态更新\r\n---------------\r\n运行HTTP中对Portal的定期访问，并且执行auth更新操作。\r\n\r\n\r\n```\r\njava -jar papa.jar\r\n\r\ncd /vagrant/dea_ng/lib/dea/conup_test\r\nruby update_hello.rb\r\n\r\n```\r\n\r\n\r\n常见错误\r\n----------------------\r\n\r\n##1  push java应用出现oom \r\n\r\n 是因为CF不支持带有命令行读入操作的应用\r\n\r\ntuscany的源码支持从命令行读入用户输入的命令，这会导致该进程阻塞。而CF认为这样的阻塞是不合理的，因此会kill掉当前进程。\r\n\r\n将tuscany源码中的shell模块的\r\n\r\n##2 安装gem失败\r\n删除根目录下的.gem文件夹。再试试。（遇到marshaldata too short，删除.gem，重新执行一遍）\r\n\r\n\r\n## 3 启动warden后可能会报错 \r\n\r\nquotaon:Mountpointor device)/not found or has no quota enabled\r\n\r\n解决方法，重启quota，这个是网上给的解决方法，我这里出现这个错误应该是warden中没有安装quota。还是需要quotaon -a的。\r\n\r\n```\r\n  quotaoff –a \r\n  \r\n  quotacheck –avugm\r\n  \r\n  quotaon -a   \r\n\r\n```\r\n\r\n\r\n## 4 error:cannot  loadsuch file -- zlib \r\n\r\n\r\n安装一下zlib1-dev\r\n\r\n```\r\nsudo apt-get install zlib1g-dev\r\n```\r\n\r\n\r\n## 5 bundle install 遇到 ExtensionBuildError问题时\r\n\r\n\r\n尝试一下安装ruby-dev，或者ruby1.8-dev或者ruby-1.9dev，这取决于你出问题的ruby版本，这里我使用的是\r\n\r\n```\r\nsudo apt-get install ruby1.9.1-dev\r\n\r\n```\r\n\r\n我是在本地化CloudFoundry时，遇到各种gem install问题的\r\n\r\n安装bcrypt-ruby失败\r\n尝试解决1：rm –rfvendor/bundle\r\n \r\natomic安装失败\r\n安装ruby1.9.1-dev，\r\n\r\n```\r\nsudo apt-get install ruby1.9.1-dev\r\n\r\n```\r\n\r\n安装到nokogiri时，遇到“libxml2is missing”\r\n\r\n再执行\r\n\r\n```\r\nsudo apt-get install libxslt-dev libxml2-dev \r\n\r\n```\r\n\r\n\r\n## 6 cc在mysql2失败\r\n```\r\nsudo apt-get install libmysql-ruby libmysqlclient-dev\r\n\r\n```\r\n结果pg失败，\r\n\r\n```\r\nsudo apt-get install libpq-dev\r\n\r\n```\r\nsqlite3失败\r\n\r\n\r\n```\r\nsudo apt-get install libsqlite3-dev\r\n\r\n```\r\n\r\n\r\n\r\n## 7 CFoundry::AppPackageInvalid: 150001: The app package is invalid: failed repacking application\r\n\r\n可能是warden容器中没有安装zip\r\n\r\nsudo chroot .到stemcell中手动安装的\r\n首先\r\n apt-get update \r\n然后 \r\n\r\n```\r\napt-get install quota gcc iptables zip\r\n\r\n```\r\n\r\n\r\n\r\n## 8 install vagrant vagrant-berkshelf plugin 失败\r\n\r\n主要是nokogiri安装失败，解决如下：\r\n\r\n\r\n```\r\n\r\nsudo apt-get install zlib1g-dev lib64z1-dev\r\n\r\nNOKOGIRI_USE_SYSTEM_LIBRARIES=1 vagrant plugin install vagrant-berkshelf\r\n\r\n\r\n```\r\n\r\n## 9 gorouter启动失败\r\n\r\n第一次连接NATS server时，是因为nats还未启动成功，因此dial tcp 127.0.0.1:4222 : connection regused，这个属于正常行为。\r\n如果连接失败。每隔1s会发起一次连接请求。\r\n\r\n\r\n但第二次连接时，报错json: cannot unmarshal null into Go value of type bool，应该是哪里传了一个空指针。\r\n\r\nlog发现，host，user，pass都是正确的。\r\n\r\n在执行r.natsClient.RunWithDefaults(host,user,pass)报错。\r\n\r\n重启，重新启动都失败。\r\n\r\nsrc/router/logger.go:4: import /vagrant/gorouter/pkg/linux_amd64/github.com/cloudfoundry/gosteno.a: object is [linux amd64 go1.0.3 X:none] expected [linux amd64 go1 X:none]\r\n\r\n重新生成router可执行文件\r\n\r\n```\r\n ./bin/go  install router/router\r\n\r\n```\r\n\r\n这里应该是go版本的问题 ， 粗暴解决\r\n\r\n```\r\ngo install -a -v all\r\n\r\n```\r\n\r\n\r\n\r\n\r\n## 10 warden容器抛出oom错误\r\n\r\n有可能真是oom，那么此时就需要增加内存\r\n\r\n能正常cf push nodejs应用(设置内存限制256M)，java-web应用(设置内存限制512M)\r\n\r\n然后跑php，jboss/ejb， tuscany/sca应用时，就开始报oom了。\r\n\r\n \r\n \r\n1 扩大Vagrant虚拟机内存\r\n2 扩大应用内存：无效\r\n3 debug。。。\r\n\r\n\r\n这里是因为CF不支持部署等待命令行输入的应用\r\n\r\n\r\n\r\n\r\n\r\n\r\n-----------------\r\n\r\n\r\n\r\n遇到错误多查看日志\r\n------------------------\r\n\r\n/vagrant/logs主要查看dea和warden的日志\r\n\r\n/tmp/dea_ng/目录是dea_ng部署的临时文件夹，也可以查看部署的droplet等\r\n\r\n可以通过warden-client查看warden-server是否运行正常\r\n\r\n\r\n\r\n[1]:http://www.vagrantup.com\r\n[2]:http://www.virtualbox.org\r\n[3]:http://packages.ubuntu.com/vivid/all/liberror-perl/download\r\n[4]:http://www.oracle.com/technetwork/java/javase/downloads/index.html?ssSourceSiteId=ocomen\r\n[5]:http://docs.cloudfoundry.com/docs/running/architecture/warden.html","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}